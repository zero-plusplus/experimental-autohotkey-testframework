class Util {
  /**
   * @param {any} value
   * @return {boolean}
   */
  static isNamedFunc(value) {
    if (value is Func && UnitTest.Util.tryGetProp(value, "name")) {
      return true
    }
    return false
  }
  /**
   * @param {any} a
   * @param {any} b
   * @return {boolean}
   */
  static equals(a, b) {
    return a == b
  }
  /**
   * @param {any} a
   * @param {any} b
   * @return {boolean}
   */
  static equalsIgnoreCase(a, b) {
    return a = b
  }
  /**
   * @param {any} a
   * @param {any} b
   * @param {(a, b) => boolean} b?
   * @return {boolean}
   */
  static deepEquals(a, b, equiv := "", _stack := "") {
    equiv := equiv || (a, b) => a == b
    _stack := _stack ? _stack : []

    isAnyPrimitive := !(IsObject(a) && IsObject(b))
    if (isAnyPrimitive) {
      return equiv(a, b)
    }
    else if (equiv(a, b)) {
        return true
    }

    isCircular := this.includes(_stack, a)
    if (isCircular) {
        return false
    }
    _stack.push(a)

    keys_a := this.ownKeys(a)
    keys_b := this.ownKeys(b)

    if (keys_a.length != keys_b.length) {
        return false
    }

    Loop keys_a.length {
        if (!equiv(keys_a[A_Index], keys_b[A_Index])) {
            return false
        }
    }

    for i, key in keys_a {
        value_a := this.getProp(a, key)
        value_b := this.getProp(b, key)

         if (!this.deepEquals(value_a, value_b, equiv, _stack)) {
            return false
        }
    }
    return true
  }
  /**
   * @param {any} a
   * @param {any} b
   * @return {boolean}
   */
  static deepEqualsIgnoreCase(a, b) {
    return this.deepEquals(a, b, (a, b) => a = b)
  }
  /**
   * @param {string} str
   * @param {number} count
   */
  static repeatStr(str, count) {
    repeated := ""
    Loop count {
      repeated .= str
    }
    return repeated
  }
  /**
   * @param {string} str
   * @return {string[]}
   */
  static splitLines(str) {
    str := StrReplace(str, "`r`n", "`n")
    return StrSplit(str, "`n")
  }
  /**
   * @param {string} str
   * @param {number} indentSize
   */
  static indentStr(str, indentSize) {
    str := StrReplace(str, "`r`n", "`n")
    indent := UnitTest.Util.repeatStr(" ", indentSize)

    indented := ""
    for i, line in StrSplit(str, "`n") {
      indented .= indent . line "`n"
    }

    indented := RTrim(indented, "`n")
    return indented
  }
  /**
   * @param {any} value
   * @return {boolean}
   */
  static toBoolean(value) {
    return !!value
  }
  /**
   * @param {string} str
   * @return {string}
   */
  static toCamelCase(str) {
    if (InStr(str, "-")) {
      words := StrSplit(str, "-")
      camelCased := words.removeAt(1)
      for i, word in words {
        camelCased .= StrTitle(word)
      }
      return camelCased
    }
    return str
  }
  /**
   * @param {object} obj
   * @return {Enumerator}
   */
  static getEnum(obj) {
    if (!IsObject(obj)) {
      return [].__Enum(2)
    }
    if (obj is Class) {
      return obj.prototype.ownProps()
    }
    if (obj is Array || obj is Map) {
      return obj.__Enum(2)
    }
    return obj.ownProps()
  }
  /**
   * @param {object} obj
   */
  static flatEntries(obj) {
    flatEntries := []
    for key, value in UnitTest.Util.getEnum(obj) {
      flatEntries.push(key, value)
    }
    return flatEntries
  }
  /**
   * @param {array} arr
   * @param {string} str
   * @param {(a, b) => boolean} equiv
   */
  static includes(arr, str, equiv := "") {
    equiv := equiv || (a, b) => a == b
    for i, value in arr {
      if (equiv(str, value)) {
        return true
      }
    }
    return false
  }
  /**
   * @template T
   * @param {object<T, any>} obj
   * @return {T[]} keys
   */
  static ownKeys(obj) {
    keys := []
    for key in this.getEnum(obj) {
      keys.push(key)
    }
    return keys
  }
  /**
   * @template T
   * @param {object<any, T>} obj
   * @param {any} key
   * @return {T}
   */
  static getProp(obj, key) {
    if (obj is Map || obj is Array) {
      return obj[key]
    }
    return obj.%key%
  }
  /**
   * Get the child elements from an object.
   * Returns `default` if an error occurred.
   * @param {object} obj
   * @param {any} key
   * @param {any} [default := ""] - The value returned if it cannot be retrieved.
   */
  static tryGetProp(obj, key, default := "") {
    try {
      return this.getProp(obj, key) || default
    }
    return default
  }
  /**
   * @param {callable} callable
   * @param {any[]} params*
   * @return {any}
   */
  static tryCall(callable, params*) {
    try {
      return callable(params*)
    }
  }
  /**
   * @param {string} name
   * @return {any}
   */
  static reflectByName(__name__) {
    global ; It is necessary to be careful with the variable names to avoid conflicts with global variables

    if (InStr(__name__, ".") == 0) {
      local __value__ := %__name__%
      return __value__
    }

    local __path__ := StrSplit(__name__, ".")
    local __rootName__ := __path__.removeAt(1)
    local __root__ := %__rootName__%
    local __i__ := ""
    local __part__ := ""
    for __i__, __part__ in __path__ {
      __root__ := __root__.%__part__%
    }
    return __root__
  }
  /**
   * @param {number} offsetByTop
   * @return {Error[]}
   */
  static getCallStack(offsetByTop := 0) {
    stacks := []

    startFrame := 2 + offsetByTop
    while (true) {
      e := Error("", -(startFrame + (A_Index - 1)))
      if (e.what == "" || IsNumber(e.what)) {
        break
      }
      stacks.push(e)
    }

    ; The what properties are off by one, unlike the actual stack properties, so fix them here
    if (0 < stacks.length) {
      for i, stack in stacks {
        if (i + 1 <= stacks.length) {
          nextStack := stacks[i + 1]
          stack.what := nextStack.what
        }
      }
      stacks.pop() ; The last stack should be removed because it is covered with information
    }
    return stacks
  }
  /**
   * @param {string} file
   * @param {number} line
   * @return {string}
   */
  static readFileLine(file, line) {
    file := FileOpen(file, "r")
    lineText := ""
    Loop line {
      lineText := file.readLine()
    }
    return lineText
  }
  /**
   * Parses arguments with the following syntax For simplicity, no whitespace is allowed.
   * Syntax:
   * --example-bool
   * --example-string=string
   * --example-strings=string1,string2,string3
   * @return {Map<string, primitive>}
   */
  static parseArgs(replacer := "") {
    global A_Args
    if (!replacer) {
      replacer := (values*) => values
    }
    argMap := Map()
    scriptArgs := []

    isArgWithValue := true
    for i, arg in A_Args {
      if (arg == "--") {
        isArgWithValue := false
        continue
      }
      if (isArgWithValue) {
        RegExMatch(arg, "i)-(-)?(?<name>[^\s=]+)(?:=(?<value>[^\s]+))?", &match)
        a := match["name"], match["value"] !== "" ? match["value"] : true
        replaced := replacer(match["name"], match["value"] !== "" ? match["value"] : true)
        argMap[replaced[1]] := replaced[2]
      }
      else {
        scriptArgs.push(arg)
      }
    }

    argMap["scriptArgs"] := scriptArgs
    return argMap
  }
  /**
   * @param {any} value
   * @return {string}
   */
  class stringify {
    static call(value) {
      if (value is String) {
        return this.string(value)
      }
      if (value is Number) {
        return this.number(value)
      }
      if (value is Array) {
        return this.array(value)
      }
      if (value is Map) {
        return this.map(value)
      }
      return this.object(value)
    }
    static string(str) {
      return Format('"{}"', str)
    }
    static number(num) {
      return String(num)
    }
    static object(obj) {
      colon := ": "
      comma := ", "

      str := "{ "
      for key, value in obj.ownProps() {
        str .= key . colon . this.call(value) . comma
      }
      str := RTrim(str, comma)
      str .= " }"

      return str
    }
    static array(arr) {
      comma := ", "

      str := "[ "
      for i, value in arr {
        str .= this.call(value) . comma
      }
      str := RTrim(str, comma)
      str .= " ]"

      return str
    }
    static map(_map) {
      pairDelimiter := " => "
      comma := ", "

      str := "[ "
      for key, value in _map {
        str .= this.call(key) . pairDelimiter . this.call(value) . comma
      }
      str := RTrim(str, comma)
      str .= " ]"

      return str
    }
  }
}