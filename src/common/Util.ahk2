class Util {
  /**
   * @param {any} value
   * @return {boolean}
   */
  static isNamedFunc(value) {
    if (value is Func && UnitTest.Util.tryGetProp(value, "name")) {
      return true
    }
    return false
  }
  /**
   * @param {any} a
   * @param {any} b
   * @return {boolean}
   */
  static equals(a, b) {
    return a == b
  }
  /**
   * @param {string} str
   * @param {number} count
   */
  static repeatStr(str, count) {
    repeated := ""
    Loop count {
      repeated .= str
    }
    return repeated
  }
  /**
   * @param {string} str
   * @return {string[]}
   */
  static splitLines(str) {
    str := StrReplace(str, "`r`n", "`n")
    return StrSplit(str, "`n")
  }
  /**
   * @param {string} str
   * @param {number} indentSize
   */
  static indentStr(str, indentSize) {
    str := StrReplace(str, "`r`n", "`n")
    indent := UnitTest.Util.repeatStr(" ", indentSize)

    indented := ""
    for i, line in StrSplit(str, "`n") {
      indented .= indent . line "`n"
    }

    indented := RTrim(indented, "`n")
    return indented
  }
  /**
   * @param {any} value
   * @return {boolean}
   */
  static toBoolean(value) {
    return !!value
  }
  /**
   * @param {string} str
   * @return {string}
   */
  static toCamelCase(str) {
    if (InStr(str, "-")) {
      words := StrSplit(str, "-")
      camelCased := words.removeAt(1)
      for i, word in words {
        camelCased .= StrTitle(word)
      }
      return camelCased
    }
    return str
  }
  /**
   * @param {object} obj
   * @return {Enumerator}
   */
  static getEnum(obj) {
    if (!IsObject(obj)) {
      return [].__Enum()
    }
    if (obj is Class) {
      return obj.prototype.ownProps()
    }
    if (obj is Array || obj is Map) {
      return obj.__Enum()
    }
    return obj.ownProps()
  }
  /**
   * @param {object} obj
   */
  static flatEntries(obj) {
    flatEntries := []
    for key, value in UnitTest.Util.getEnum(obj) {
      flatEntries.push(key, value)
    }
    return flatEntries
  }
  /**
   * @template T
   * @param {object<any, T>} obj
   * @param {any} key
   * @return {T}
   */
  static getProp(obj, key) {
    if (obj is Map || obj is Array) {
      return obj[key]
    }
    return obj.%key%
  }
  /**
   * Get the child elements from an object.
   * Returns `default` if an error occurred.
   * @param {object} obj
   * @param {any} key
   * @param {any} [default := ""] - The value returned if it cannot be retrieved.
   */
  static tryGetProp(obj, key, default := "") {
    try {
      return this.getProp(obj, key) || default
    }
    return default
  }
  /**
   * @param {callable} callable
   * @param {any[]} params*
   * @return {any}
   */
  static tryCall(callable, params*) {
    try {
      return callable(params*)
    }
  }
  /**
   * @param {string} name
   * @return {any}
   */
  static reflectByName(__name__) {
    global ; It is necessary to be careful with the variable names to avoid conflicts with global variables

    if (InStr(__name__, ".") == 0) {
      local __value__ := %__name__%
      return __value__
    }

    local __path__ := StrSplit(__name__, ".")
    local __rootName__ := __path__.removeAt(1)
    local __root__ := %__rootName__%
    local __i__ := ""
    local __part__ := ""
    for __i__, __part__ in __path__ {
      __root__ := __root__.%__part__%
    }
    return __root__
  }
  /**
   * @param {number} offsetByTop
   * @return {Error[]}
   */
  static getCallStack(offsetByTop := 0) {
    stacks := []

    startFrame := 2 + offsetByTop
    while (true) {
      e := Error("", -(startFrame + (A_Index - 1)))
      if (e.what == "" || IsNumber(e.what)) {
        break
      }
      stacks.push(e)
    }

    ; The what properties are off by one, unlike the actual stack properties, so fix them here
    if (0 < stacks.length) {
      for i, stack in stacks {
        if (i + 1 <= stacks.length) {
          nextStack := stacks[i + 1]
          stack.what := nextStack.what
        }
      }
      stacks.pop() ; The last stack should be removed because it is covered with information
    }
    return stacks
  }
  /**
   * @param {string} file
   * @param {number} line
   * @return {string}
   */
  static readFileLine(file, line) {
    file := FileOpen(file, "r")
    lineText := ""
    Loop line {
      lineText := file.readLine()
    }
    return lineText
  }
  /**
   * Parses arguments with the following syntax For simplicity, no whitespace is allowed.
   * Syntax:
   * --example-bool
   * --example-string=string
   * --example-strings=string1,string2,string3
   * @return {Map<string, primitive>}
   */
  static parseArgs(replacer := "") {
    global A_Args
    if (!replacer) {
      replacer := (values*) => values
    }
    argMap := Map()
    scriptArgs := []

    isArgWithValue := true
    for i, arg in A_Args {
      if (arg == "--") {
        isArgWithValue := false
        continue
      }
      if (isArgWithValue) {
        RegExMatch(arg, "i)-(-)?(?<name>[^\s=]+)(?:=(?<value>[^\s]+))?", &match)
        a := match["name"], match["value"] !== "" ? match["value"] : true
        replaced := replacer(match["name"], match["value"] !== "" ? match["value"] : true)
        argMap[replaced[1]] := replaced[2]
      }
      else {
        scriptArgs.push(arg)
      }
    }

    argMap["scriptArgs"] := scriptArgs
    return argMap
  }
}