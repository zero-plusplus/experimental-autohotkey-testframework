class CuiReporter extends UnitTest.rule.Reporter {
  exit(summary) {
    total := summary.getResults().length
    successes := summary.getSuccesses().length
    failures := summary.getFailures().length
    message := Format(">>> {} testing of {} passed, {} failed.", total, successes, failures)
    this._write(0 < failures ? "stderr" : "stdout", message)
  }
  /**
   * @param {Class} testClass
   */
  start(testClass) {
    namePathArray := StrSplit(testClass.__class, ".")
    testName := namePathArray.pop()
    this._writeStdOutLine(testName, namePathArray.length)
  }
  startEach(testMethod) {
    namePathArray := StrSplit(testMethod.name, ".")
    testName := namePathArray.pop()
    this._writeStdOutLine("[" testName "]", namePathArray.length - 1)
  }
;   end(testClass, summary) {
;     total := summary.getResults().length
;     successes := summary.getSuccesses().length
;     failures := summary.getFailures().length
;     message := Format(">>> {} testing of {} passed, {} failed.", total, successes, failures)
;     this._writeStdOutLine(message, StrSplit(testClass.__class, ".").length - 1)
;   }
  endEach(tester) {
    if (!tester.error) {
      return
    }

    err := tester.error
    testName := RegExReplace(tester.testMethod.name, "i)\.Prototype", "")
    indentSize := StrSplit(testName, ".").length
    message := Format(">>> Error: {}", err.message)
    if (err.hasOwnProp("extra") && err.extra) {
      message .= Format("`n>>> Specifically: {}", err.extra)
    }
    this._writeStdErrLine(message, indentSize)

    for i, callInfo in err.callStack {
      this._writeStdErrLine(callInfo.file ":" callInfo.line " [" callInfo.what "]", indentSize + 1)
    }
  }
  result(result) {
    testName := RegExReplace(result.testMethod.name, "i)\.Prototype", "")
    indentSize := StrSplit(testName, ".").length
    mark := result.success ? "✔" : "❌"
    message := mark ": " result.message
    this._writeStdOutLine(message, indentSize)

    if (!result.success) {
      for i, callInfo in result.callStack {
        this._writeStdErrLine(callInfo.file ":" callInfo.line " [" callInfo.what "]", indentSize + 1)
      }
    }
  }
  /**
   * @private
   * @param {"stdout" | "stderr"} dest
   * @param {string} message
   * @param {number | class | callable} [indentLevel := 0]
   */
  _write(dest, message, indentLevel := 0) {
    if (UnitTest.isTestClass(indentLevel)) {
      testClass := indentLevel
      indentLevel := StrSplit(testClass.__class, ".").length - 1
    }
    else if (UnitTest.isTestMethod(indentLevel)) {
      testMethod := indentLevel
      indentLevel := StrSplit(RegExReplace(testMethod.name, "i)\.Prototype", ""), ".")
    }

    message := UnitTest.Util.repeatStr(" ", indentLevel * 2) . message
    dest := (dest = "stderr") ? "**" : "*"
    if (dest == "stderr" && isSet(A_DebuggerName) && A_DebuggerName == "Visual Studio Code") {
      OutputDebug(message)
      return
    }
    FileAppend(message, dest)
  }
  /**
   * @private
   * @param {string} message
   * @param {number | class | callable} indentLevel
   */
  _writeStdOut(message, indentLevel := 0) {
    this._write("stdout", message, indentLevel)
  }
  /**
   * @private
   * @param {string} message
   * @param {number | class | callable} indentLevel
   */
  _writeStdOutLine(message, indentLevel := 0) {
    this._writeStdOut(message "`n", indentLevel)
  }
  /**
   * @private
   * @param {string} message
   * @param {number | class | callable} indentLevel
   */
  _writeStdErr(message, indentLevel := 0) {
    this._write("stderr", message, indentLevel)
  }
  /**
   * @private
   * @param {string} message
   * @param {number | class | callable} indentLevel
   */
  _writeStdErrLine(message, indentLevel := 0) {
    this._writeStdErr(message "`n", indentLevel)
  }
}