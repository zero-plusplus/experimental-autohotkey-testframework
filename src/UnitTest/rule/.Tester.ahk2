class Tester {
  ;; @tyep {UnitTest}
  framework := ""
  ;; @type {Callable}
  testMethod := ""
  ;; @type {UnitTest.TestResult[]}
  results := []
  ;; @type {UnitTest.TestResult[]}
  successes := []
  ;; @type {UnitTest.TestResult[]}
  failures := []
  ;; @type {Error | ""}
  error := ""

  /**
   * @param {UnitTest.rule.Reporter} testMethod
   * @param {callable} testMethod
   */
  __New(framework, testMethod) {
    this.framework := framework
    this.testMethod := testMethod
  }
  /**
   * @return {boolean}
   */
  hasError() {
    return 0 < this.failures.length
  }
  /**
   * @param {boolean} success
   * @param {any} actual
   * @param {any} expected
   * @param {string} description
   * @param {Error} err?
   */
  result(success, actual, expected, description, err := "") {
    callstack := []
    if (err) {
      callstack.push(err, UnitTest.Util.getCallStack()*)
    }
    else {
      callstack.push(UnitTest.Util.getCallStack(1)*)
    }

    if (description == "") {
      lineText := UnitTest.Util.readFileLine(callStack[1].file, callStack[1].line)
      RegExMatch(lineText, "i)^\s*[\w_]+\.(.+)\s*$", &match)
      description := match[1]
    }
    if (!success) {
      additionalDescription := Format("`nactual:   {}`nexpected: {}", UnitTest.Util.stringify(actual), UnitTest.Util.stringify(expected))
      description .= UnitTest.Util.indentStr(additionalDescription, 2)
    }

    result := UnitTest.TestResult(this.testMethod, success, description, callStack)

    this.results.push(result)
    if (success) {
      this.successes.push(result)
    }
    else {
      this.failures.push(result)
    }
    UnitTest.Util.tryCall(ObjBindMethod(this.framework.reporter, "result"), result)
  }
}